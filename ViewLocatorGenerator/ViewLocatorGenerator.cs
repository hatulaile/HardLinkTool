using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ViewLocatorGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class StaticViewLocatorGenerator : IIncrementalGenerator
{
    private const string STATIC_VIEW_LOCATOR_ATTRIBUTE_DISPLAY_STRING = "StaticViewLocator.StaticViewLocatorAttribute";
    private const string VIEW_MODEL_SUFFIX = "ViewModel";
    private const string VIEW_SUFFIX = "View";

    private const string ATTRIBUTE_TEXT =
        """
        // <auto-generated />
        using System;

        namespace StaticViewLocator;

        [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        public sealed class StaticViewLocatorAttribute : Attribute
        {
        }

        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx =>
            ctx.AddSource("StaticViewLocatorAttribute.cs", SourceText.From(ATTRIBUTE_TEXT, Encoding.UTF8)));

        var viewModelsProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax classDeclaration &&
                                    classDeclaration.Identifier.ValueText.EndsWith(VIEW_MODEL_SUFFIX,
                                        StringComparison.Ordinal),
                static (generatorContext, cancellationToken) =>
                {
                    var classDeclaration = (ClassDeclarationSyntax)generatorContext.Node;
                    if (generatorContext.SemanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken) is not
                        { } symbol)
                    {
                        return null;
                    }

                    return symbol.IsAbstract ? null : symbol;
                })
            .Where(static symbol => symbol is not null)
            .Select(static (symbol, _) => symbol!)
            .Collect();

        var locatorsProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
            STATIC_VIEW_LOCATOR_ATTRIBUTE_DISPLAY_STRING,
            static (node, _) => node is ClassDeclarationSyntax,
            static (attributeContext, _) => (INamedTypeSymbol)attributeContext.TargetSymbol);

        var inputs = locatorsProvider
            .Combine(context.CompilationProvider)
            .Combine(viewModelsProvider);

        context.RegisterSourceOutput(inputs, static (sourceProductionContext, tuple) =>
        {
            var ((locatorSymbol, compilation), viewModelSymbols) = tuple;

            var classSource = ProcessClass(compilation, locatorSymbol, viewModelSymbols);
            if (classSource is not null)
            {
                sourceProductionContext.AddSource(
                    $"{locatorSymbol.Name}_StaticViewLocator.cs",
                    SourceText.From(classSource, Encoding.UTF8));
            }
        });
    }

    private static string? ProcessClass(Compilation compilation, INamedTypeSymbol locatorSymbol,
        ImmutableArray<INamedTypeSymbol> viewModelSymbols)
    {
        if (!locatorSymbol.ContainingSymbol.Equals(locatorSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
        {
            return null;
        }

        var namespaceNameLocator = locatorSymbol.ContainingNamespace.ToDisplayString();

        var buildMethodExists = locatorSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Any(method => method.Name == "Build" && method.Parameters.Length == 1);

        var format = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters |
                             SymbolDisplayGenericsOptions.IncludeTypeConstraints |
                             SymbolDisplayGenericsOptions.IncludeVariance);

        var classNameLocator = locatorSymbol.ToDisplayString(format);

        var relevantViewModels = new List<INamedTypeSymbol>();
        var seen = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        foreach (var symbol in viewModelSymbols)
        {
            if (!symbol.Name.EndsWith(VIEW_MODEL_SUFFIX, StringComparison.Ordinal) || symbol.IsAbstract)
            {
                continue;
            }

            if (seen.Add(symbol))
            {
                relevantViewModels.Add(symbol);
            }
        }

        relevantViewModels.Sort(static (left, right) =>
            string.Compare(left.ToDisplayString(), right.ToDisplayString(), StringComparison.Ordinal));

        var source = new StringBuilder(
            $$"""
              // <auto-generated />
              #nullable enable
              using System;
              using System.Collections.Generic;
              using Avalonia.Controls;
              using Microsoft.Extensions.DependencyInjection;

              namespace {{namespaceNameLocator}};

              public partial class {{classNameLocator}}
              {
                  private static Dictionary<Type, Func<Control>> s_views = new();
                  public static void Initialize(IServiceCollection services)
              """);

        source.AppendLine();
        source.AppendLine("\t{");


        var userControlViewSymbol = compilation.GetTypeByMetadataName("Avalonia.Controls.Control");

        foreach (var viewModelSymbol in relevantViewModels)
        {
            var namespaceNameViewModel = viewModelSymbol.ContainingNamespace.ToDisplayString();
            var classNameViewModel = $"{namespaceNameViewModel}.{viewModelSymbol.ToDisplayString(format)}";
            var classNameView = classNameViewModel.Replace(VIEW_MODEL_SUFFIX, VIEW_SUFFIX);

            var viewSymbol = compilation.GetTypeByMetadataName(classNameView);
            if (viewSymbol is null || !InheritsFrom(viewSymbol, userControlViewSymbol!))
            {
                source.AppendLine(
                    $"\t\ts_views.Add(typeof({classNameViewModel}), () => new TextBlock() {{ Text = \"Not Found: {classNameView}\"}});");
            }
            else
            {
                source.AppendLine(
                    $"\t\tservices.AddTransient<{classNameViewModel}>();");
                source.AppendLine($$"""
                                    		services.AddTransient<{{classNameView}}>(sp =>
                                                new {{classNameView}}(){DataContext = sp.GetRequiredService<{{classNameViewModel}}>()});
                                    """);
                source.AppendLine($"\t\ts_views.Add(typeof({classNameViewModel}), () => new {classNameView}());");
            }

            source.AppendLine();
        }

        source.AppendLine("\t}");

        if (!buildMethodExists)
        {
            source.Append(
                """

                	public Control? Build(object? data)
                	{
                		if (data is null)
                		{
                			return null;
                		}

                		var type = data.GetType();

                		if (s_views.TryGetValue(type, out var func))
                		{
                			return func.Invoke();
                		}

                		throw new Exception($"Unable to create view for type: {type}");
                	}

                """);
        }

        source.AppendLine("}");

        return source.ToString();
    }

    private static bool InheritsFrom(INamedTypeSymbol symbol, INamedTypeSymbol userControlViewSymbol)
    {
        var current = symbol;
        while (current != null)
        {
            if (current.Equals(userControlViewSymbol, SymbolEqualityComparer.Default))
                return true;
            current = current.BaseType;
        }

        return false;
    }
}
