using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ViewModelIoCGenerator;

[Generator(LanguageNames.CSharp)]
public class ViewModelIoCGenerator : IIncrementalGenerator
{
    private const string ATTRIBUTE_DISPLAY_STRING = "ViewModelIoCGenerator.IgnoreIoCGeneratorAttribute";
    private const string WINDOW_MODEL_SUFFIX = "WindowViewModel";
    private const string WINDOW_SUFFIX = "Window";
    private const string VIEW_MODEL_SUFFIX = "ViewModel";
    private const string VIEW_SUFFIX = "View";

    private const string ATTRIBUTE_TEXT =
        """
        // <auto-generated />
        using System;

        namespace ViewModelIoCGenerator;

        [global::System.AttributeUsageAttribute(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        public sealed class IgnoreIoCGeneratorAttribute : Attribute;
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static igpc =>
            igpc.AddSource("IgnoreIoCGeneratorAttribute.g.cs", ATTRIBUTE_TEXT));

        var viewModelsProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax classDeclaration &&
                                    classDeclaration.Identifier.ValueText.EndsWith(VIEW_MODEL_SUFFIX,
                                        StringComparison.Ordinal)
                ,
                static (generatorContext, cancellationToken) =>
                {
                    var classDeclaration = (ClassDeclarationSyntax)generatorContext.Node;
                    if (generatorContext.SemanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken) is not
                        { } symbol)
                    {
                        return null;
                    }

                    if (symbol.GetAttributes().Any(x =>
                            x.AttributeClass?.ToDisplayString().Equals(ATTRIBUTE_DISPLAY_STRING) ?? true))
                    {
                        return null;
                    }

                    return symbol.IsAbstract ? null : symbol;
                })
            .Where(static symbol => symbol is not null)
            .Select(static (symbol, _) => symbol!)
            .Collect();

        var inputs = context.CompilationProvider
            .Combine(viewModelsProvider);

        context.RegisterSourceOutput(inputs, static (sourceProductionContext, tuple) =>
        {
            (Compilation compilation, ImmutableArray<INamedTypeSymbol> viewModelSymbols) = tuple;
            if (viewModelSymbols.Length == 0) return;
            var classSource = ProcessClass(compilation, viewModelSymbols);
            sourceProductionContext.AddSource(
                "ServiceCollectionExtension.g.cs",
                SourceText.From(classSource, Encoding.UTF8));
        });
    }

    private static string ProcessClass(Compilation compilation, ImmutableArray<INamedTypeSymbol> viewModelSymbols)
    {
        var relevantViewModels = new List<INamedTypeSymbol>();
        var seen = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        foreach (var symbol in viewModelSymbols)
        {
            if (!symbol.Name.EndsWith(VIEW_MODEL_SUFFIX, StringComparison.Ordinal) || symbol.IsAbstract)
            {
                continue;
            }

            if (seen.Add(symbol))
            {
                relevantViewModels.Add(symbol);
            }
        }

        var format = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters |
                             SymbolDisplayGenericsOptions.IncludeTypeConstraints |
                             SymbolDisplayGenericsOptions.IncludeVariance);

        relevantViewModels.Sort(static (left, right) =>
            string.Compare(left.ToDisplayString(), right.ToDisplayString(), StringComparison.Ordinal));

        var source = new StringBuilder(
            $$"""
              // <auto-generated />
              #nullable enable
              using System;
              using System.Collections.Generic;
              using Microsoft.Extensions.DependencyInjection;
              using Avalonia.Controls;

              namespace ViewModelIoCGenerator;

              public static class ServiceCollectionExtension
              {
              """);

        source.AppendLine();
        source.AppendLine("\tpublic static IServiceCollection AddViewModels(this IServiceCollection services)");
        source.AppendLine("\t{");
        var controlViewSymbol = compilation.GetTypeByMetadataName("Avalonia.Controls.Control")!;

        foreach (var viewModelSymbol in relevantViewModels)
        {
            var classNameViewModel =
                $"{viewModelSymbol.ContainingNamespace.ToDisplayString()}.{viewModelSymbol.ToDisplayString(format)}";
            var classNameView = classNameViewModel
                .Replace(WINDOW_MODEL_SUFFIX, WINDOW_SUFFIX)
                .Replace(VIEW_MODEL_SUFFIX, VIEW_SUFFIX);
            var viewSymbol = compilation.GetTypeByMetadataName(classNameView);

            if (viewSymbol is null)
            {
                classNameView = classNameViewModel.Replace(VIEW_MODEL_SUFFIX, VIEW_SUFFIX);
                viewSymbol = compilation.GetTypeByMetadataName(classNameView);
            }

            if (viewSymbol is null || !InheritsFrom(viewSymbol, controlViewSymbol))
            {
                source.AppendLine(
                    $"// No registration for {classNameViewModel} because view not found: {classNameView}");
            }
            else
            {
                source.AppendLine($$"""
                                    		services.AddTransient<{{classNameViewModel}}>();
                                    		services.AddTransient<{{classNameView}}>(sp =>
                                    			new {{classNameView}}(){DataContext = sp.GetRequiredService<{{classNameViewModel}}>()});
                                    """);
            }
        }

        source.AppendLine("\t\treturn services;");
        source.AppendLine("\t}");
        source.AppendLine("}");
        return source.ToString();
    }

    private static bool InheritsFrom(INamedTypeSymbol symbol, INamedTypeSymbol controlSymbol)
    {
        var current = symbol;
        while (current != null)
        {
            if (current.Equals(controlSymbol, SymbolEqualityComparer.Default))
                return true;
            current = current.BaseType;
        }

        return false;
    }
}
